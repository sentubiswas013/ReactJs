## Java Platform

### 1. Why is Java so popular?

* Java is popular because itâ€™s **platform-independent**â€”write once, run anywhere.
* It has **strong memory management**, **good security**, and a **huge ecosystem**.
* Java is widely used in **enterprise apps, banking, Android, and backend services**.
* Big frameworks like **Spring, Hibernate**, and strong community support make it reliable.

```java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Java runs everywhere");
    }
}
```

ðŸ‘‰ Same program runs on Windows, Linux, or Mac.

---

### 2. What is platform independence?

* Platform independence means **Java code doesnâ€™t depend on the OS**.
* Java source code is compiled into **bytecode**, not machine code.
* This bytecode runs on **any system that has a JVM**.
* JVM handles OS-specific things internally.

```java
// Compile once
javac Hello.java

// Run anywhere with JVM
java Hello
```

ðŸ‘‰ JVM acts as a bridge between Java code and OS.

---

### 3. What is bytecode?

* Bytecode is the **intermediate code** generated by the Java compiler.
* Itâ€™s stored in `.class` files.
* Bytecode is **not machine-specific**.
* JVM reads bytecode and converts it to machine code at runtime.

```bash
javac Test.java   // creates Test.class (bytecode)
```

ðŸ‘‰ This is the main reason Java is portable.

---

### 4. Compare JDK vs JVM vs JRE

* **JVM** â†’ Executes bytecode (runtime engine).
* **JRE** â†’ JVM + core libraries (to run Java programs).
* **JDK** â†’ JRE + development tools (to write Java programs).

```text
JDK = JRE + Compiler (javac)
JRE = JVM + Libraries
JVM = Executes bytecode
```

ðŸ‘‰ Developers need **JDK**, users need only **JRE**.

---

### 5. Differences between C++ and Java

* Java is **platform-independent**, C++ is platform-dependent.
* Java has **automatic garbage collection**, C++ uses manual memory management.
* Java doesnâ€™t support **pointers**, making it safer.
* Java supports **multithreading by default**.

```java
// Java (no pointers)
int a = 10;
```

```cpp
// C++ (pointers)
int a = 10;
int* p = &a;
```

ðŸ‘‰ Java is safer and easier for large applications.

---

### 6. Role of ClassLoader in Java

* ClassLoader loads **.class files into memory** at runtime.
* It follows **three levels**:

  * Bootstrap
  * Extension
  * Application
* It helps with **security and modular loading**.

```java
ClassLoader cl = Test.class.getClassLoader();
System.out.println(cl);
```

ðŸ‘‰ Classes are loaded **only when needed**, improving performance.

---

## Wrapper Classes

### 7. What are Wrapper classes?

* Wrapper classes convert **primitive data types into objects**.
* Each primitive has a corresponding wrapper class.
* They are used when an object is required instead of a primitive.
* Examples: `int â†’ Integer`, `double â†’ Double`.

```java
int a = 10;
Integer obj = Integer.valueOf(a);
```

---

### 8. Why do we need Wrapper classes in Java?

* Java collections work only with **objects**, not primitives.
* Wrapper classes provide **utility methods** like parsing and conversion.
* They help in **object-oriented programming**.
* Required for features like **auto boxing**.

```java
ArrayList<Integer> list = new ArrayList<>();
list.add(10);
```

---

### 9. Ways of creating Wrapper class instances

* Using **constructor** (deprecated).
* Using **valueOf() method**.
* Using **auto boxing**.

```java
Integer a = new Integer(10);      // deprecated
Integer b = Integer.valueOf(10);
Integer c = 10;                   // auto boxing
```

---

### 10. Differences between the two ways of creating Wrapper classes

* `new Integer()` always creates a **new object**.
* `valueOf()` uses **caching** for better performance.
* `valueOf()` is **recommended**.

```java
Integer a = Integer.valueOf(100);
Integer b = Integer.valueOf(100);
System.out.println(a == b); // true (cached)
```

---

### 11. What is auto boxing?

* Auto boxing is **automatic conversion of primitive to wrapper object**.
* Done by the compiler.
* Reduces boilerplate code.

```java
int a = 10;
Integer obj = a;  // auto boxing
```

---

### 12. Advantages of auto boxing

* Cleaner and **more readable code**.
* Easy to work with **collections**.
* Less manual conversion.

```java
List<Integer> list = List.of(1, 2, 3);
```

---

### 13. What is casting?

* Casting means **converting one data type to another**.
* Commonly used between primitive types.
* Can be implicit or explicit.

```java
int a = 10;
double d = a;
```

---

### 14. What is implicit casting?

* Done **automatically** by Java.
* Happens when converting **smaller to larger** data type.
* No data loss.

```java
int a = 10;
double d = a;  // implicit casting
```

---

### 15. What is explicit casting?

* Done **manually** by the programmer.
* Used when converting **larger to smaller** data type.
* May cause data loss.

```java
double d = 10.5;
int a = (int) d;  // explicit casting
```

## Java Strings

### 16. Are all Strings immutable?

* Yes, **String objects are immutable** in Java.
* Once created, the value **cannot be changed**.
* Any modification creates a **new String object**.
* This helps with **security, caching, and performance**.

```java
String s = "Java";
s.concat(" World");
System.out.println(s); // Java (unchanged)
```

---

### 17. Where are String values stored in memory?

* String literals are stored in the **String Constant Pool (SCP)**.
* Strings created using `new` are stored in **heap memory**.
* SCP helps in **memory optimization** by reusing strings.

```java
String s1 = "Java";           // SCP
String s2 = new String("Java"); // Heap
```

---

### 18. Why be careful with String concatenation (`+`) in loops?

* Strings are immutable, so `+` creates **new objects every time**.
* In loops, this causes **performance and memory issues**.
* Too many temporary objects slow down the application.

```java
String s = "";
for(int i = 0; i < 1000; i++) {
    s = s + i; // inefficient
}
```

---

### 19. How do you solve the String concatenation problem?

* Use **StringBuilder** or **StringBuffer** instead.
* They are mutable and efficient for repeated modifications.
* Preferred in loops and large string operations.

```java
StringBuilder sb = new StringBuilder();
for(int i = 0; i < 1000; i++) {
    sb.append(i);
}
String result = sb.toString();
```

---

### 20. Differences between String and StringBuffer

* `String` is **immutable**, `StringBuffer` is **mutable**.
* `StringBuffer` is **thread-safe**, `String` is not.
* Use `String` for constants, `StringBuffer` for frequent changes.

```java
String s = "Hello";
StringBuffer sb = new StringBuffer("Hello");
sb.append(" World");
```

---

### 21. Differences between StringBuilder and StringBuffer

* `StringBuilder` is **not thread-safe**.
* `StringBuffer` is **thread-safe (synchronized)**.
* `StringBuilder` is **faster** and preferred in single-threaded apps.

```java
StringBuilder sb = new StringBuilder("Java");
sb.append(" 8+");
```

---

### 22. Utility methods in String class

* `length()` â€“ returns string length
* `charAt()` â€“ returns character at index
* `substring()` â€“ extracts part of string
* `toUpperCase()` / `toLowerCase()`
* `equals()` / `equalsIgnoreCase()`

```java
String s = "Java";
System.out.println(s.length());
System.out.println(s.substring(1)); // ava
```

---

## Object Oriented Programming Basics

### 23. What is a class?

* A class is a **blueprint or template** for creating objects.
* It defines **properties (variables)** and **behaviors (methods)**.
* No memory is allocated when a class is created.
* Objects are created from the class.

```java
class Car {
    String color;
    void drive() {
        System.out.println("Car is driving");
    }
}
```

---

### 24. What is an object?

* An object is a **real-world instance of a class**.
* It represents a real entity with **state and behavior**.
* Memory is allocated when an object is created.
* Objects interact by calling methods.

```java
Car car1 = new Car();
car1.color = "Red";
car1.drive();
```

---

### 25. What is the state of an object?

* State represents the **data or values** of an object.
* It is stored in **instance variables**.
* Different objects can have different states.

```java
class User {
    String name;
    int age; // state of object
}
```

---

### 26. What is behavior of an object?

* Behavior defines **what an object can do**.
* It is represented using **methods**.
* Methods operate on the objectâ€™s state.

```java
class User {
    void login() {
        System.out.println("User logged in");
    }
}
```

---

### 27. What is the super class of every class in Java?

* `Object` class is the **super class of all Java classes**.
* It is present in `java.lang` package.
* Methods like `toString()`, `equals()`, `hashCode()` come from it.

```java
class Test {}
// Test extends Object implicitly
```

---

### 28. Explain the `toString()` method

* `toString()` returns a **string representation of an object**.
* Used mainly for **logging and debugging**.
* Can be overridden to show meaningful object data.

```java
class User {
    String name;
    public String toString() {
        return "User name: " + name;
    }
}
```

---

### 29. What is the use of the `equals()` method?

* `equals()` is used to **compare object content**, not references.
* Default implementation compares memory references.
* Commonly overridden in custom classes.

```java
String a = new String("Java");
String b = new String("Java");
System.out.println(a.equals(b)); // true
```

---

### 30. Important things when implementing `equals()` method

* Check **reference equality** (`this == obj`).
* Check **null** and class type.
* Compare only **relevant fields**.
* Always override `hashCode()` along with `equals()`.

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    User user = (User) o;
    return age == user.age && name.equals(user.name);
}
```

---

## Inheritance, Polymorphism & Interfaces

### 31. What is the `hashCode()` method used for in Java?

* `hashCode()` returns an **integer hash value** for an object.
* Used mainly in **hash-based collections** like `HashMap` and `HashSet`.
* If two objects are equal using `equals()`, they **must have same hashCode**.
* Improves performance during object lookup.

```java
String s1 = "Java";
String s2 = "Java";
System.out.println(s1.hashCode() == s2.hashCode()); // true
```

---

### 32. Explain inheritance with examples

* Inheritance allows a class to **reuse properties and methods** of another class.
* Achieved using the `extends` keyword.
* Promotes **code reusability** and **IS-A relationship**.

```java
class Animal {
    void eat() {
        System.out.println("Eating");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Barking");
    }
}
```

---

### 33. What is method overloading?

* Method overloading means **same method name with different parameters**.
* Happens in the **same class**.
* Decided at **compile time**.
* Improves code readability.

```java
class MathUtil {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
}
```

---

### 34. What is method overriding?

* Method overriding means **redefining a superclass method** in subclass.
* Method signature must be **same**.
* Decided at **runtime (dynamic binding)**.

```java
class Animal {
    void sound() { System.out.println("Animal sound"); }
}

class Dog extends Animal {
    @Override
    void sound() { System.out.println("Bark"); }
}
```

---

### 35. Can a superclass reference hold a subclass object?

* Yes, this is called **polymorphism**.
* Parent reference can refer to child object.
* Only overridden methods are called based on object type.

```java
Animal a = new Dog();
a.sound(); // Bark
```

---

### 36. Is multiple inheritance allowed in Java?

* **Not allowed using classes** due to ambiguity problem.
* Allowed using **interfaces**.
* Java avoids diamond problem this way.

```java
interface A {}
interface B {}
class C implements A, B {}
```

---

### 37. What is an interface?

* An interface is a **contract** that defines what a class must do.
* Contains **abstract methods** and **constants**.
* Supports **multiple inheritance**.

```java
interface Payment {
    void pay();
}
```

---

### 38. How do you define an interface?

* Defined using the `interface` keyword.
* A class implements it using `implements` keyword.
* All methods are public by default.

```java
interface Flyable {
    void fly();
}

class Bird implements Flyable {
    public void fly() {
        System.out.println("Bird is flying");
    }
}
```

---

## Abstraction & Interfaces

### 39. How do you implement an interface?

* A class implements an interface using the **`implements` keyword**.
* The class must provide implementations for **all abstract methods**.
* This enforces a clear contract.

```java
interface Payment {
    void pay();
}

class CreditCardPayment implements Payment {
    public void pay() {
        System.out.println("Payment done via credit card");
    }
}
```

---

### 40. Tricky things about interfaces

* Methods are **public by default**.
* Variables are **public static final (constants)**.
* Interfaces can have **default and static methods** (Java 8+).
* Cannot create objects of interfaces.

```java
interface Demo {
    int X = 10; // constant
    default void show() {
        System.out.println("Default method");
    }
}
```

---

### 41. Can you extend an interface?

* Yes, an interface can **extend one or more interfaces**.
* It supports **multiple inheritance**.
* No implementation is required while extending.

```java
interface A {
    void a();
}

interface B extends A {
    void b();
}
```

---

### 42. Can a class extend multiple interfaces?

* A class cannot extend multiple classes.
* But it can **implement multiple interfaces**.
* This is how Java achieves multiple inheritance.

```java
class MyClass implements A, B {
    public void a() {}
    public void b() {}
}
```

---

### 43. What is an abstract class?

* An abstract class is a **partially implemented class**.
* It can have **abstract and non-abstract methods**.
* Objects of abstract classes **cannot be created**.

```java
abstract class Shape {
    abstract void draw();
}
```

---

### 44. When do you use an abstract class?

* When classes share **common code and behavior**.
* When you want to provide **base functionality**.
* Useful for **IS-A relationships with default behavior**.

```java
abstract class Vehicle {
    void start() {
        System.out.println("Vehicle started");
    }
}
```

---

### 45. How do you define an abstract method?

* Use the **`abstract` keyword**.
* Abstract methods have **no body**.
* Subclasses must implement them.

```java
abstract class Animal {
    abstract void sound();
}
```

---

### 46. Abstract class vs Interface

* Abstract class supports **methods with implementation**.
* Interface supports **multiple inheritance**.
* Abstract class can have **constructors and instance variables**.
* Interface focuses on **what to do**, not how.

```java
abstract class A {
    void show() {}
}

interface B {
    void show();
}
```

---

## Constructors

### 47. What is a constructor?

* A constructor is a **special method used to initialize objects**.
* It has the **same name as the class**.
* It does **not have a return type**.
* It is called automatically when an object is created.

```java
class User {
    User() {
        System.out.println("User object created");
    }
}
```

---

### 48. What is a default constructor?

* A default constructor has **no parameters**.
* If no constructor is defined, Java provides one automatically.
* It initializes objects with **default values**.

```java
class Test {
    // default constructor provided by compiler
}

Test t = new Test();
```

---

### 49. How do you call a superclass constructor?

* Use the **`super()` keyword**.
* It must be the **first statement** in the constructor.
* Used to initialize parent class data.

```java
class Parent {
    Parent(int x) {
        System.out.println(x);
    }
}

class Child extends Parent {
    Child() {
        super(10);
    }
}
```

---

### 50. What is the use of `this()`?

* `this()` is used to call **another constructor of the same class**.
* Helps avoid **code duplication**.
* Must be the **first statement** in constructor.

```java
class Demo {
    Demo() {
        this(5);
    }
    Demo(int x) {
        System.out.println(x);
    }
}
```

---

### 51. Can a constructor be called directly from a method?

* No, constructors **cannot be called like methods**.
* They are invoked only during **object creation using `new`**.
* You can call methods from constructors, not vice versa.

```java
// Invalid
// obj.Demo();

Demo d = new Demo(); // valid
```

---

### 52. Is superclass constructor called implicitly?

* Yes, if not explicitly called, Java automatically calls **`super()`**.
* Happens only if superclass has a **no-arg constructor**.
* Ensures proper object initialization.

```java
class A {
    A() {
        System.out.println("A constructor");
    }
}

class B extends A {
    B() {
        System.out.println("B constructor");
    }
}
```

---

## Advanced Object Oriented Concepts

### 53. What is polymorphism?

* Polymorphism means **one interface, multiple implementations**.
* Same method behaves **differently based on object type**.
* Achieved using **method overriding**.
* Helps in **flexible and extensible code**.

```java
Animal a = new Dog();
a.sound(); // Bark
```

---

### 54. Use of `instanceof` operator

* Used to check **object type at runtime**.
* Prevents `ClassCastException`.
* Commonly used before type casting.

```java
if (a instanceof Dog) {
    Dog d = (Dog) a;
}
```

---

### 55. What is coupling?

* Coupling refers to **dependency between classes**.
* **Tight coupling** makes code hard to change.
* **Loose coupling** improves maintainability.
* Interfaces help reduce coupling.

```java
class Car {
    Engine engine; // loosely coupled via reference
}
```

---

### 56. What is cohesion?

* Cohesion means how **focused a class is on one task**.
* High cohesion = better readability and maintenance.
* Each class should have **single responsibility**.

```java
class UserService {
    void createUser() {}
}
```

---

### 57. What is encapsulation?

* Encapsulation means **hiding data** and exposing behavior.
* Achieved using **private variables and public methods**.
* Protects object integrity.

```java
class User {
    private int age;
    public int getAge() { return age; }
}
```

---

### 58. What is an inner class?

* An inner class is a **class inside another class**.
* It can access outer class members.
* Used for **logical grouping**.

```java
class Outer {
    class Inner {}
}
```

---

### 59. What is a static inner class?

* A static inner class belongs to the **outer class, not instance**.
* Can access only **static members** of outer class.
* Used for helper classes.

```java
class Outer {
    static class Helper {}
}
```

---

### 60. Can you create an inner class inside a method?

* Yes, itâ€™s called a **local inner class**.
* Scope is limited to the method.
* Used for short-term logic.

```java
void method() {
    class Local {}
}
```

---

### 61. What is an anonymous class?

* Anonymous class has **no name**.
* Used for **one-time implementations**.
* Common with interfaces and abstract classes.

```java
Runnable r = new Runnable() {
    public void run() {
        System.out.println("Running");
    }
};
```

---

## Modifiers

### 62. What is the default class modifier?

* A top-level class with no modifier has **default (package-private)** access.
* It is accessible **only within the same package**.
* Used to restrict visibility at package level.

```java
class DefaultClass {
    // accessible only in same package
}
```

---

### 63. What is the private access modifier?

* `private` members are accessible **only within the same class**.
* Used for **data hiding and encapsulation**.
* Not accessible outside the class.

```java
class User {
    private int age;
}
```

---

### 64. What is the default or package access modifier?

* When no modifier is specified, it is **package-private**.
* Accessible **within the same package only**.
* Helps in grouping related classes.

```java
class Employee {
    int id; // package-private
}
```

---

### 65. What is the protected access modifier?

* `protected` members are accessible **within same package**.
* Also accessible in **subclasses in other packages**.
* Used in inheritance scenarios.

```java
class Parent {
    protected String name;
}
```

---

### 66. What is the public access modifier?

* `public` members are accessible **from anywhere**.
* No access restriction.
* Used for APIs and public methods.

```java
public class Service {
    public void execute() {}
}
```

---

### 67. Access types available within the same package?

* `private` â†’ âŒ (only same class)
* `default` â†’ âœ…
* `protected` â†’ âœ…
* `public` â†’ âœ…

```java
// Same package access
// default, protected, public allowed
```

---

### 68. Access types available from a different package?

* `private` â†’ âŒ
* `default` â†’ âŒ
* `protected` â†’ âœ… (only through inheritance)
* `public` â†’ âœ…

```java
// Different package
// public always accessible
// protected via subclass only
```

---

## Modifiers & Keywords

### 69. Access types available from a subclass in the same package?

* `private` â†’ âŒ (only same class)
* `default` â†’ âœ…
* `protected` â†’ âœ…
* `public` â†’ âœ…
* Subclass behaves like a normal class inside the package.

```java
// Same package subclass
// default, protected, public accessible
```

---

### 70. Access types available from a subclass in a different package?

* `private` â†’ âŒ
* `default` â†’ âŒ
* `protected` â†’ âœ… (via inheritance only)
* `public` â†’ âœ…

```java
class Child extends Parent {
    void test() {
        // can access protected & public
    }
}
```

---

### 71. Use of `final` modifier on a class?

* A `final` class **cannot be inherited**.
* Used to prevent modification of class behavior.
* Improves security and design clarity.

```java
final class Utility {}
// class Test extends Utility {} // error
```

---

### 72. Use of `final` modifier on a method?

* A `final` method **cannot be overridden**.
* Used to lock method implementation.
* Common in framework base classes.

```java
class Parent {
    final void show() {}
}
```

---

### 73. What is a final variable?

* A `final` variable value **cannot be changed** once assigned.
* Works like a constant.
* Must be initialized only once.

```java
final int MAX = 100;
```

---

### 74. What is a final argument?

* A final argument **cannot be reassigned** inside method.
* Prevents accidental modification.
* Object state can still change.

```java
void test(final int x) {
    // x = 5; // error
}
```

---

### 75. What happens when a variable is marked `volatile`?

* Ensures variable value is **read from main memory**.
* Used in **multi-threading**.
* Prevents caching issues between threads.

```java
volatile boolean flag = true;
```

---

### 76. What is a static variable?

* A static variable belongs to the **class**, not object.
* Shared across all instances.
* Loaded once when class is loaded.

```java
class Counter {
    static int count = 0;
}
```

---

# Java â€“ Conditions & Loops

## 77. Why should you always use blocks around an `if` statement?

* Using `{}` blocks makes code **safe, readable, and maintainable**.
* It prevents **logical bugs** when adding new lines later.
* Java allows single-line `if` without braces, but that often causes mistakes.
* Teams and real projects always enforce braces as a best practice.

**Example:**

```java
// âŒ Risky (bug-prone)
if (isLoggedIn)
    System.out.println("Welcome");
    loadDashboard(); // always runs

// âœ… Safe and clear
if (isLoggedIn) {
    System.out.println("Welcome");
    loadDashboard();
}
```

---

## 78. Should `default` be the last case in a switch statement?

* **Yes, by convention**, `default` should be the last case.
* Logically, it handles **all remaining unmatched cases**.
* Technically, Java allows `default` anywhere, but it reduces readability.
* Keeping it last makes the switch easier to understand and debug.

**Example:**

```java
switch (day) {
    case 1:
        System.out.println("Monday");
        break;
    case 2:
        System.out.println("Tuesday");
        break;
    default:
        System.out.println("Invalid day");
}
```

---

## 79. Can a switch statement be used around a `String`?

* **Yes**, since Java 7, `switch` supports `String`.
* It compares **string values**, not references.
* Useful for menu handling, commands, API responses, and user input.
* Cleaner and faster than long `if-else` chains.

**Example:**

```java
String role = "ADMIN";

switch (role) {
    case "ADMIN":
        System.out.println("Full access");
        break;
    case "USER":
        System.out.println("Limited access");
        break;
    default:
        System.out.println("Guest access");
}
```

---

## 80. What is an enhanced for loop?

* Also called the **for-each loop**.
* Used to iterate over **arrays and collections** easily.
* No index handling â†’ **cleaner and less error-prone**.
* Best when you only need values, not indexes.

**Example:**

```java
int[] numbers = {1, 2, 3, 4};

for (int num : numbers) {
    System.out.println(num);
}
```

**With Collection:**

```java
List<String> names = List.of("Java", "Spring", "React");

for (String name : names) {
    System.out.println(name);
}
```

---

# Java â€“ Exception Handling 

## 81. Why is exception handling important?

* It prevents the application from **crashing unexpectedly**.
* Helps handle runtime problems like **null values, IO errors, divide by zero**.
* Improves **program stability, reliability, and user experience**.
* Separates **normal logic** from **error-handling logic**.

**Example:**

```java
try {
    int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Cannot divide by zero");
}
```

---

## 82. What design pattern is used to implement exception handling features in most languages?

* Exception handling follows the **Chain of Responsibility pattern**.
* An exception is thrown and passed **up the call stack**.
* The first matching `catch` block handles it.
* If no handler is found, the program terminates.

**Example:**

```java
void methodA() {
    methodB();
}

void methodB() {
    throw new RuntimeException("Error occurred");
}
```

---

## 83. What is the need for a `finally` block?

* `finally` is used to **clean up resources**.
* It executes **whether exception occurs or not**.
* Commonly used to close **files, DB connections, streams**.
* Ensures no resource leak happens.

**Example:**

```java
try {
    System.out.println("Processing");
} catch (Exception e) {
    System.out.println("Error");
} finally {
    System.out.println("Cleanup done");
}
```

---

## 84. In what scenarios is code in `finally` not executed?

* If the JVM **crashes**.
* If `System.exit()` is called.
* If power failure or OS-level termination happens.
* Otherwise, `finally` almost always executes.

**Example:**

```java
try {
    System.exit(0);
} finally {
    System.out.println("Will not execute");
}
```

---

## 85. Will `finally` be executed in the program below?

* **Yes**, if no `System.exit()` or JVM crash occurs.
* Even if `return` is used inside `try` or `catch`.
* `finally` executes **before method returns**.

**Example:**

```java
try {
    return;
} finally {
    System.out.println("Finally executed");
}
```

---

## 86. Is `try` without a `catch` allowed?

* **Yes**, if it is followed by a `finally` block.
* Useful when you only want **cleanup logic**.
* Exception will still propagate after `finally`.

**Example:**

```java
try {
    int x = 10 / 0;
} finally {
    System.out.println("Cleanup");
}
```

---

## 87. Is `try` without `catch` and `finally` allowed?

* **No**, Java does not allow it.
* A `try` block must be followed by:

  * at least one `catch`, or
  * a `finally`, or
  * both.
* Otherwise, it causes a **compile-time error**.

**Example (Invalid):**

```java
try {
    int x = 10;
}
```

---

## 88. Can you explain the hierarchy of exception handling classes?

* `Throwable` is the **root class**.
* It has two children:

  * `Error`
  * `Exception`
* `Exception` further divides into:

  * Checked exceptions
  * Unchecked (`RuntimeException`)

**Hierarchy:**

```
Throwable
 â”œâ”€â”€ Error
 â””â”€â”€ Exception
      â””â”€â”€ RuntimeException
```

---

## 89. What is the difference between Error and Exception?

* **Error** represents serious system problems.
* Errors are usually **not recoverable**.
* **Exception** represents application-level issues.
* Exceptions **can be handled** using try-catch.

**Example:**

```java
// Exception (Recoverable)
int x = Integer.parseInt("abc");

// Error (Not recoverable)
// OutOfMemoryError
```

---

## 90. What is the difference between checked exceptions and unchecked exceptions?

* **Checked exceptions** are checked at **compile time**.
* They must be **handled or declared** using `throws`.
* **Unchecked exceptions** occur at **runtime**.
* They extend `RuntimeException` and are not mandatory to handle.

**Example:**

```java
// Checked Exception
FileReader fr = new FileReader("file.txt");

// Unchecked Exception
int x = 10 / 0; // ArithmeticException
```

---

## 91. How do you throw an exception from a method?

* Use the `throw` keyword.
* You can throw **built-in or custom exceptions**.
* Typically used for **business rule validation**.

**Example:**

```java
void withdraw(int amount) {
    if (amount < 0) {
        throw new IllegalArgumentException("Invalid amount");
    }
}
```

---

## 92. What happens when you throw a checked exception from a method?

* The compiler forces you to **handle or declare** it.
* You must use `throws` in the method signature.
* Otherwise, compilation fails.

**Example:**

```java
void readFile() throws IOException {
    FileReader fr = new FileReader("file.txt");
}
```

---

## 93. What are the options to eliminate compilation errors for checked exceptions?

* **Catch the exception** using `try-catch`.
* **Declare it** using `throws` keyword.
* Use **try-with-resources** when applicable.

**Example:**

```java
// Option 1: Handle
try {
    readFile();
} catch (IOException e) {
    e.printStackTrace();
}

// Option 2: Declare
void process() throws IOException {
    readFile();
}
```

---

## 94. How do you create a custom exception?

* Extend `Exception` (checked) or `RuntimeException` (unchecked).
* Provide constructors with custom messages.
* Used for **domain-specific errors**.

**Example:**

```java
class InvalidAgeException extends Exception {
    InvalidAgeException(String msg) {
        super(msg);
    }
}
```

---

## 95. How do you handle multiple exception types with the same catch block?

* Use **multi-catch** (Java 7+).
* Cleaner and avoids code duplication.
* Exceptions must not have parent-child relationship.

**Example:**

```java
try {
    int x = Integer.parseInt("abc");
} catch (NumberFormatException | NullPointerException e) {
    System.out.println("Invalid input");
}
```

---

## 96. Can you explain try-with-resources?

* Introduced in **Java 7**.
* Automatically closes resources after use.
* Removes the need for `finally`.
* Works with classes implementing `AutoCloseable`.

**Example:**

```java
try (FileReader fr = new FileReader("file.txt")) {
    System.out.println("Reading file");
}
```

---

## 97. How does try-with-resources work?

* JVM calls `close()` automatically.
* Resources are closed **in reverse order**.
* Even if an exception occurs, cleanup is guaranteed.

**Example:**

```java
try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
    System.out.println(br.readLine());
}
```

---

## 98. Can you explain a few exception handling best practices?

* Catch **specific exceptions**, not generic ones.
* Never swallow exceptions silently.
* Use custom exceptions for business logic.
* Log exceptions properly.
* Avoid using exceptions for flow control.

**Example:**

```java
try {
    process();
} catch (IOException e) {
    logger.error(e.getMessage());
}
```

---

#  Miscellaneous Topics

## 99. What are the default values in an array?

* In Java, array elements automatically get default values.
* The default value depends on the data type of the array.
* This avoids uninitialized variable errors.

**Common defaults:**

* `int`, `short`, `byte`, `long` â†’ `0`
* `float`, `double` â†’ `0.0`
* `char` â†’ `\u0000`
* `boolean` â†’ `false`
* Object references â†’ `null`

```java
int[] nums = new int[3];
System.out.println(nums[0]); // 0

String[] names = new String[2];
System.out.println(names[0]); // null
```

---

## 100. How do you loop around an array using an enhanced for loop?

* The enhanced for loop is also called the for-each loop.
* It is used when you only need to read elements, not indexes.
* It makes code cleaner and more readable.

```java
int[] numbers = {10, 20, 30};

for (int num : numbers) {
    System.out.println(num);
}
```

* You cannot modify array indexes using this loop.

---

## 101. How do you print the content of an array?

* Using a normal loop prints elements one by one.
* `Arrays.toString()` is the easiest and cleanest way.

```java
import java.util.Arrays;

int[] arr = {1, 2, 3};
System.out.println(Arrays.toString(arr));
```

* For multi-dimensional arrays, use `Arrays.deepToString()`.

```java
int[][] matrix = {{1, 2}, {3, 4}};
System.out.println(Arrays.deepToString(matrix));
```

---

## 102. How do you compare two arrays?

* Using `==` compares references, not content.
* Use `Arrays.equals()` to compare values.

```java
import java.util.Arrays;

int[] a = {1, 2, 3};
int[] b = {1, 2, 3};

System.out.println(Arrays.equals(a, b)); // true
```

* For multi-dimensional arrays, use `Arrays.deepEquals()`.

---

## 103. What is an enum?

* An enum is a special data type that represents fixed constants.
* It improves type safety and readability.
* Enums are commonly used for status, roles, or directions.

```java
enum Status {
    ACTIVE, INACTIVE, BLOCKED
}

Status userStatus = Status.ACTIVE;
```

* Enums are better than constants because they are compile-time safe.

---

## 104. Can you use a switch statement around an enum?

* Yes, enums work perfectly with switch statements.
* Java handles enum values efficiently in switch cases.

```java
Status status = Status.ACTIVE;

switch (status) {
    case ACTIVE:
        System.out.println("User is active");
        break;
    case INACTIVE:
        System.out.println("User is inactive");
        break;
    default:
        System.out.println("Blocked user");
}
```

* No need to use the enum name inside `case`.

---

## 105. What are variable arguments or varargs?

* Varargs allow passing multiple arguments to a method.
* Internally, varargs are treated as an array.
* It reduces method overloading.

```java
public static void printNumbers(int... nums) {
    for (int n : nums) {
        System.out.println(n);
    }
}

printNumbers(1, 2, 3, 4);
```

* Varargs must be the **last parameter** in a method.

---

## 106. What are asserts used for?

* Assertions are used for debugging and testing assumptions.
* They help detect logical errors during development.
* Assertions are disabled by default at runtime.

```java
int age = 15;
assert age >= 18 : "Age must be 18 or above";
```

* Enable assertions using:

```bash
java -ea MyClass
```

* Assertions should not be used for production validations.

---

## 107. When should asserts be used?

* Assertions should be used during development and testing.
* They are meant to validate assumptions that should never fail.
* Assertions help catch logical bugs early.

```java
int speed = 80;
assert speed > 0 : "Speed must be positive";
```

* They should **not** be used for user input or production validation.

---

## 108. What is garbage collection?

* Garbage collection is Javaâ€™s automatic memory management process.
* It removes objects that are no longer being used.
* This prevents memory leaks and reduces developer effort.

```java
String s = new String("Java");
s = null; // object eligible for garbage collection
```

* Developers donâ€™t manually free memory in Java.

---

## 109. Can you explain garbage collection with an example?

* When no reference points to an object, it becomes eligible for GC.
* The garbage collector frees heap memory automatically.

```java
public void demo() {
    Person p = new Person();
    p = null; // object is now unused
}
```

* Java decides *when* to clean up, not the programmer.

---

## 110. When is garbage collection run?

* Garbage collection runs automatically when JVM needs memory.
* The timing is not guaranteed.
* Calling `System.gc()` only *requests* GC.

```java
System.gc(); // suggestion, not a command
```

* JVM decides the best time based on performance.

---

## 111. What are best practices on garbage collection?

* Avoid creating unnecessary objects.
* Set unused object references to `null` if needed.
* Use local variables with limited scope.
* Avoid calling `System.gc()` explicitly.

```java
void process() {
    String temp = "data"; // eligible for GC after method ends
}
```

* Let the JVM manage memory efficiently.

---

## 112. What are initialization blocks?

* Initialization blocks are used to initialize variables.
* They execute when an object or class is loaded.
* Java has two types: static and instance blocks.

```java
{
    System.out.println("Initialization block");
}
```

* They run before constructors.

---

## 113. What is a static initializer?

* A static initializer runs once when the class is loaded.
* It is used to initialize static variables.

```java
static {
    System.out.println("Static block executed");
}
```

* It executes before `main()` method.

---

## 114. What is an instance initializer block?

* Instance initializer blocks run every time an object is created.
* They execute before the constructor.

```java
{
    System.out.println("Instance block executed");
}

public MyClass() {
    System.out.println("Constructor executed");
}
```

* Useful for common initialization logic.

---

## 115. What is tokenizing?

* Tokenizing is breaking a string into smaller pieces called tokens.
* It is commonly used in parsing input or processing text.

```java
String data = "Java,Spring,React";
String[] tokens = data.split(",");

for (String t : tokens) {
    System.out.println(t);
}
```

* Java also provides `StringTokenizer`, but `split()` is preferred.

---

## 116. Can you give an example of tokenizing?

* Tokenizing splits a string into smaller parts called tokens.
* Useful for parsing CSV, logs, or user input.

```java
String data = "Java,Spring,React";
String[] tokens = data.split(",");
for (String t : tokens) System.out.println(t);
```

* Output:

```
Java
Spring
React
```

---

## 117. What is serialization?

* Serialization converts an object into a byte stream.
* Enables saving objects to file or sending over network.
* Implemented using `Serializable` interface.

---

## 118. How do you serialize an object using the `Serializable` interface?

```java
import java.io.*;
class Person implements Serializable {
    String name; int age;
    Person(String name, int age) { this.name = name; this.age = age; }
}

Person p = new Person("Alice", 25);
try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("person.dat"))) {
    out.writeObject(p);
} catch (IOException e) { e.printStackTrace(); }
```

---

## 119. How do you de-serialize in Java?

```java
try (ObjectInputStream in = new ObjectInputStream(new FileInputStream("person.dat"))) {
    Person p2 = (Person) in.readObject();
    System.out.println(p2.name + " - " + p2.age);
} catch (IOException | ClassNotFoundException e) { e.printStackTrace(); }
```

* Reads byte stream back into object.

---

## 120. What do you do if only parts of the object have to be serialized?

* Use `transient` keyword for fields not to be serialized.

```java
class Person implements Serializable {
    String name;
    transient int age; // won't be serialized
}
```

* On de-serialization, `age` defaults to `0`.

---

## 121. How do you serialize a hierarchy of objects?

* All classes in the object graph must implement `Serializable`.
* Serialization automatically handles referenced objects.

```java
class Address implements Serializable { String city; }
class Person implements Serializable { String name; Address address; }
```

* Both `Person` and `Address` implement `Serializable`.

---

## 122. Are the constructors in an object invoked when it is de-serialized?

* **No**, constructors are not called.
* Object is recreated from the byte stream.

---

## 123. Are the values of static variables stored when an object is serialized?

* **No**, static variables belong to the class, not instance.
* Only instance variables are serialized.
* Manage static values separately if needed.

---

# Java Collections Interview Q&A

## 124. Why do we need collections in Java?

* Collections provide a standard way to store and manipulate groups of objects.
* They eliminate the need to write custom data structures like arrays or linked lists.
* Collections are dynamic, type-safe, and come with built-in methods for searching, sorting, and iterating.

```java
List<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
```

## 125. What are the important interfaces in the collection hierarchy?

* Main interfaces: **Collection**, **List**, **Set**, **Queue**, **Deque**.
* **Map** is not part of Collection but is often used together.
* Each interface defines different behaviors:

  * **List** â†’ ordered, allows duplicates.
  * **Set** â†’ no duplicates.
  * **Queue/Deque** â†’ FIFO/LIFO operations.

## 126. What are the important methods that are declared in the Collection interface?

* Common methods:

  * `add()`, `remove()`, `size()`, `clear()`, `contains()`, `isEmpty()`, `iterator()`.

```java
Collection<String> c = new ArrayList<>();
c.add("Hello");
c.contains("Hello"); // true
c.size(); // 1
```

## 127. Can you explain briefly about the List interface?

* **List** is an ordered collection that allows duplicates and nulls.
* Elements can be accessed by **index**.
* Common implementations: `ArrayList`, `LinkedList`, `Vector`.

```java
List<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
String first = list.get(0); // Java
```

## 128. Explain about ArrayList with an example

* **ArrayList** is a resizable array, part of the List interface.
* It allows fast random access but slow insert/delete in the middle.

```java
ArrayList<String> al = new ArrayList<>();
al.add("Java");
al.add("Python");
al.add("C++");
System.out.println(al); // [Java, Python, C++]
```

## 129. Can an ArrayList have duplicate elements?

* Yes, ArrayList allows duplicate elements.

```java
ArrayList<String> al = new ArrayList<>();
al.add("Java");
al.add("Java"); // duplicate allowed
System.out.println(al); // [Java, Java]
```

## 130. How do you iterate around an ArrayList using iterator?

```java
ArrayList<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}
```

* Iterator provides safe traversal, avoids `ConcurrentModificationException`.

## 131. How do you sort an ArrayList?

* Use `Collections.sort()` for natural ordering.

```java
ArrayList<String> list = new ArrayList<>();
list.add("Banana");
list.add("Apple");
list.add("Mango");
Collections.sort(list);
System.out.println(list); // [Apple, Banana, Mango]
```

## 132. How do you sort elements in an ArrayList using the `Comparable` interface?

* Implement `Comparable` in the class to define natural order.

```java
class Student implements Comparable<Student> {
    String name;
    int age;
    Student(String n, int a) { name = n; age = a; }
    public int compareTo(Student s) { return this.age - s.age; }
}

ArrayList<Student> students = new ArrayList<>();
students.add(new Student("Alice", 23));
students.add(new Student("Bob", 20));
Collections.sort(students);
for(Student s : students) System.out.println(s.name); // Bob, Alice
```

---

## 133. How do you sort elements in an ArrayList using the `Comparator` interface?

* **Comparator** is used for custom sorting logic without modifying the class.

```java
ArrayList<String> list = new ArrayList<>();
list.add("Banana");
list.add("Apple");
list.add("Mango");

// Sort by length of string
Collections.sort(list, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
});
System.out.println(list); // [Apple, Mango, Banana]
```

* You can also use lambda for shorter syntax:

```java
Collections.sort(list, (s1, s2) -> s1.length() - s2.length());
```

## 134. What is the `Vector` class? How is it different from an `ArrayList`?

* **Vector** is a synchronized, resizable array (legacy class).
* Main difference: `Vector` is **thread-safe**, `ArrayList` is **not**.

```java
Vector<String> v = new Vector<>();
v.add("Java");
v.add("Python");
```

## 135. What is `LinkedList`? What interfaces does it implement? How is it different from an `ArrayList`?

* **LinkedList** stores elements as nodes with pointers (doubly linked list).
* Implements: `List`, `Deque`, `Queue`.
* Difference from ArrayList:

  * **Faster insert/delete** in the middle.
  * **Slower random access** by index.

```java
LinkedList<String> ll = new LinkedList<>();
ll.add("Java");
ll.add("Python");
ll.addFirst("C++"); // adds at start
```

## 136. Can you briefly explain the `Set` interface?

* **Set** is a collection that **does not allow duplicates**.
* No guaranteed order (unless using specific implementations).

```java
Set<String> set = new HashSet<>();
set.add("Java");
set.add("Java"); // ignored
```

## 137. What are the important interfaces related to the `Set` interface?

* `HashSet` â†’ basic implementation, no order.
* `LinkedHashSet` â†’ maintains insertion order.
* `SortedSet` â†’ maintains elements in **sorted order**.
* `NavigableSet` â†’ extends SortedSet with navigation methods.

## 138. What is the difference between `Set` and `SortedSet` interfaces?

* `Set` â†’ no duplicates, no guaranteed order.
* `SortedSet` â†’ no duplicates **and elements are sorted** automatically.

```java
SortedSet<Integer> ss = new TreeSet<>();
ss.add(30);
ss.add(10);
ss.add(20);
System.out.println(ss); // [10, 20, 30]
```

## 139. Can you give examples of classes that implement the `Set` interface?

* `HashSet`, `LinkedHashSet`, `TreeSet`.

## 140. What is a `HashSet`?

* **HashSet** implements `Set` using a hash table.
* Features:

  * No duplicates.
  * No guaranteed order.
  * Fast operations (add/remove/contains) ~O(1).

```java
HashSet<String> hs = new HashSet<>();
hs.add("Java");
hs.add("Python");
```

## 141. What is a `LinkedHashSet`? How is it different from a `HashSet`?

* **LinkedHashSet** preserves **insertion order**.
* Internally uses a linked list along with hash table.

```java
LinkedHashSet<String> lhs = new LinkedHashSet<>();
lhs.add("Java");
lhs.add("Python");
lhs.add("C++");
System.out.println(lhs); // [Java, Python, C++]
```

* `HashSet` order is unpredictable.

## 142. What is a `TreeSet`? How is it different from a `HashSet`?

* **TreeSet** stores elements in **sorted order** using a Red-Black tree.
* Features:

  * No duplicates.
  * Automatically sorted.
  * Slower than HashSet for basic operations (~O(log n)).

```java
TreeSet<Integer> ts = new TreeSet<>();
ts.add(30);
ts.add(10);
ts.add(20);
System.out.println(ts); // [10, 20, 30]
```

* Unlike HashSet, TreeSet **maintains order**.

## 143. Can you give examples of implementations of `NavigableSet`?

* **NavigableSet** extends SortedSet and allows navigation methods like `lower()`, `higher()`, `floor()`, `ceiling()`.
* Implementations: `TreeSet` (most commonly used).

```java
NavigableSet<Integer> ns = new TreeSet<>();
ns.add(10); ns.add(20); ns.add(30);
System.out.println(ns.ceiling(15)); // 20
```

## 144. Explain briefly about the `Queue` interface

* **Queue** is a collection for **holding elements before processing**, typically FIFO.
* Common methods: `add()`, `offer()`, `poll()`, `peek()`.

```java
Queue<String> q = new LinkedList<>();
q.add("Java"); q.add("Python");
System.out.println(q.poll()); // Java
```

## 145. What are the important interfaces related to the `Queue` interface?

* `Deque` â†’ double-ended queue (insert/remove from both ends)
* `BlockingQueue` â†’ thread-safe queue for producer-consumer.
* `PriorityQueue` â†’ queue with natural or custom ordering.

## 146. Explain about the `Deque` interface

* **Deque** = double-ended queue.
* Can be used as stack or queue.
* Methods: `addFirst()`, `addLast()`, `removeFirst()`, `removeLast()`.

```java
Deque<String> deque = new LinkedList<>();
deque.addFirst("Java"); deque.addLast("Python");
System.out.println(deque); // [Java, Python]
```

## 147. Explain the `BlockingQueue` interface

* **BlockingQueue** is a thread-safe queue.
* Blocks on **insert** if full and **remove** if empty.
* Used in producer-consumer scenarios.
* Methods: `put()`, `take()`.

```java
BlockingQueue<Integer> bq = new ArrayBlockingQueue<>(5);
bq.put(1); bq.put(2);
System.out.println(bq.take()); // 1
```

## 148. What is a `PriorityQueue`?

* **PriorityQueue** stores elements based on **priority**, not insertion order.
* Natural order or custom comparator.

```java
PriorityQueue<Integer> pq = new PriorityQueue<>();
pq.add(30); pq.add(10); pq.add(20);
System.out.println(pq.poll()); // 10
```

## 149. Can you give example implementations of the `BlockingQueue` interface?

* `ArrayBlockingQueue` â†’ fixed size array.
* `LinkedBlockingQueue` â†’ optionally bounded linked list.
* `PriorityBlockingQueue` â†’ priority-based thread-safe queue.

## 150. Can you briefly explain about the `Map` interface?

* **Map** stores key-value pairs, keys are unique.
* Main methods: `put()`, `get()`, `remove()`, `containsKey()`, `keySet()`, `values()`.

```java
Map<String, Integer> map = new HashMap<>();
map.put("Java", 10);
System.out.println(map.get("Java")); // 10
```

## 151. What is the difference between `Map` and `SortedMap`?

* `Map` â†’ no order guarantee.
* `SortedMap` â†’ maintains keys in **natural sorted order**.

```java
SortedMap<Integer, String> sm = new TreeMap<>();
sm.put(2, "B"); sm.put(1, "A");
System.out.println(sm); // {1=A, 2=B}
```

## 152. What is a `HashMap`?

* **HashMap** is a key-value collection using hash table.
* Features:

  * Fast O(1) get/put.
  * Allows **null key** and **null values**.
  * No order guarantee.

```java
HashMap<String, Integer> hm = new HashMap<>();
hm.put("Java", 1); hm.put("Python", 2);
```

## 153. What are the different methods in a `HashMap`?

* Common methods:

  * `put()`, `get()`, `remove()`, `containsKey()`, `containsValue()`
  * `keySet()`, `values()`, `entrySet()`, `size()`, `clear()`

```java
for(Map.Entry<String, Integer> e : hm.entrySet()) {
    System.out.println(e.getKey() + " => " + e.getValue());
}
```

## 154. What is a `TreeMap`? How is it different from a `HashMap`?

* **TreeMap** stores key-value pairs in **sorted order** of keys (natural or comparator).
* Difference from HashMap:

  * TreeMap: sorted, O(log n) operations.
  * HashMap: unsorted, O(1) operations.

```java
TreeMap<Integer, String> tm = new TreeMap<>();
tm.put(2, "B"); tm.put(1, "A");
System.out.println(tm); // {1=A, 2=B}
```

## 155. Can you give an example of implementation of `NavigableMap` interface?

* **NavigableMap** extends SortedMap, adds navigation methods: `lowerEntry()`, `floorEntry()`, `ceilingEntry()`, `higherEntry()`.
* Example: `TreeMap` implements NavigableMap.

```java
NavigableMap<Integer, String> nm = new TreeMap<>();
nm.put(10, "A"); nm.put(20, "B");
System.out.println(nm.ceilingKey(15)); // 20
```

## Functional Programming (Java 8+)

### 156. What is the functional interface - Predicate?

* **Predicate<T>** represents a boolean-valued function of one argument.
* Used for **testing conditions**.

```java
Predicate<Integer> isEven = n -> n % 2 == 0;
System.out.println(isEven.test(10)); // true
```

### 157. What is the functional interface - Function?

* **Function<T, R>** takes an input of type T and returns a result of type R.
* Used for **transformations/mapping**.

```java
Function<String, Integer> length = s -> s.length();
System.out.println(length.apply("Java")); // 4
```

### 158. What is a Consumer?

* **Consumer<T>** represents an operation that accepts a single input and returns nothing.
* Typically used for **actions** like printing or logging.

```java
Consumer<String> printer = s -> System.out.println(s);
printer.accept("Hello Java"); // Hello Java
```

### 159. Can you give examples of functional interfaces with multiple arguments?

* Examples:

  * `BiPredicate<T, U>` â†’ returns boolean, 2 args.
  * `BiFunction<T, U, R>` â†’ 2 args, returns result.
  * `BiConsumer<T, U>` â†’ 2 args, returns nothing.

```java
BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
System.out.println(add.apply(5, 3)); // 8
```

## New Features in Java Versions

### 160. What are the new features in Java 5?

* **Generics** â†’ type-safe collections.
* **Enhanced for loop** â†’ simplified iteration.
* **Autoboxing/unboxing** â†’ auto conversion between primitives and wrappers.
* **Enums** â†’ type-safe constants.
* **Varargs** â†’ variable-length arguments.
* **Metadata/Annotations** â†’ `@Override`, `@Deprecated`.

```java
for(String s : new String[]{"Java","Python"}) System.out.println(s);
```

### 161. What are the new features in Java 6?

* **Scripting support** â†’ integrate JavaScript via `javax.script`.
* **JDBC 4.0** â†’ improved database connectivity.
* **Compiler API** â†’ programmatically compile code.
* **Improved monitoring and management** with JMX.
* Mostly **performance and API enhancements**, not major language changes.

### 162. What are the new features in Java 7?

* **Diamond operator (`<>`)** â†’ type inference for generics.
* **Strings in switch** â†’ switch-case works with strings.
* **Try-with-resources** â†’ auto-close resources.
* **Numeric literals with underscores** â†’ improves readability.
* **Multi-catch exceptions** â†’ catch multiple exceptions in one block.

```java
try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
    System.out.println(br.readLine());
} catch (IOException | NullPointerException e) {
    e.printStackTrace();
}
```

### 163. What are the new features in Java 8?

* **Lambda expressions** â†’ concise functions.
* **Functional interfaces** â†’ Predicate, Function, Consumer, Supplier.
* **Stream API** â†’ process collections in a functional style.
* **Default and static methods in interfaces**.
* **Optional** â†’ avoids null checks.
* **Date/Time API** â†’ `LocalDate`, `LocalTime`, `LocalDateTime`.

```java
List<String> list = Arrays.asList("Java","Python","C++");
list.stream().filter(s -> s.startsWith("J")).forEach(System.out::println); // Java
```

---